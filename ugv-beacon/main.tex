\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage{setspace}
\usepackage{gensymb}
\singlespacing
\usepackage[cmex10]{amsmath}
\usepackage{amsthm}
\usepackage{mathrsfs}
\usepackage{txfonts}
\usepackage{stfloats}
\usepackage{bm}
\usepackage{cite}
\usepackage{cases}
\usepackage{subfig}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{tikz}
\usepackage{circuitikz}
\usepackage{verbatim}
\usepackage[breaklinks=true]{hyperref}
\usepackage{tkz-euclide} % loads  TikZ and tkz-base
\usepackage{listings}
\usepackage{color}    
\usepackage{array}    
\usepackage{longtable}
\usepackage{calc}     
\usepackage{multirow} 
\usepackage{hhline}   
\usepackage{ifthen}   
\usepackage{lscape}     
\usepackage{chngcntr}
\usepackage{algorithm}
\usepackage[indLines=false]{algpseudocodex}
\DeclareMathOperator*{\Res}{Res}
\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\arabic{subsubsection}}

\renewcommand\thesectiondis{\arabic{section}}
\renewcommand\thesubsectiondis{\thesectiondis.\arabic{subsection}}
\renewcommand\thesubsubsectiondis{\thesubsectiondis.\arabic{subsubsection}}
\renewcommand\thetable{\arabic{table}}
% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}
\def\inputGnumericTable{}                                 %%

\renewcommand\algorithmicensure{\textbf{Input:}}
\newcommand{\algorithmautorefname}{Algorithm}

\lstset{
%language=C,
frame=single, 
breaklines=true,
columns=fullflexible,
literate=
{-}{$\rightarrow{}$}{1},
}
%\lstset{
%language=tex,
%frame=single, 
%breaklines=true
%}

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\begin{document}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{example}{Example}[section]
\newtheorem{definition}[problem]{Definition}
\newcommand{\BEQA}{\begin{eqnarray}}
\newcommand{\EEQA}{\end{eqnarray}}
\newcommand{\define}{\stackrel{\triangle}{=}}
\providecommand{\mbf}{\mathbf}
\providecommand{\pr}[1]{\ensuremath{\Pr\left(#1\right)}}
\providecommand{\qfunc}[1]{\ensuremath{Q\left(#1\right)}}
\providecommand{\sbrak}[1]{\ensuremath{{}\left[#1\right]}}
\providecommand{\lsbrak}[1]{\ensuremath{{}\left[#1\right.}}
\providecommand{\rsbrak}[1]{\ensuremath{{}\left.#1\right]}}
\providecommand{\brak}[1]{\ensuremath{\left(#1\right)}}
\providecommand{\lbrak}[1]{\ensuremath{\left(#1\right.}}
\providecommand{\rbrak}[1]{\ensuremath{\left.#1\right)}}
\providecommand{\cbrak}[1]{\ensuremath{\left\{#1\right\}}}
\providecommand{\lcbrak}[1]{\ensuremath{\left\{#1\right.}}
\providecommand{\rcbrak}[1]{\ensuremath{\left.#1\right\}}}
\theoremstyle{remark}
\newtheorem{rem}{Remark}
\newcommand{\sgn}{\mathop{\mathrm{sgn}}}
\providecommand{\abs}[1]{\left\vert#1\right\vert}
\providecommand{\res}[1]{\Res\displaylimits_{#1}} 
\providecommand{\norm}[1]{\left\lVert#1\right\rVert}
\providecommand{\mtx}[1]{\mathbf{#1}}
\providecommand{\mean}[1]{E\left[ #1 \right]}   
\providecommand{\fourier}{\overset{\mathcal{F}}{ \rightleftharpoons}}
\providecommand{\system}[1]{\overset{\mathcal{#1}}{ \longleftrightarrow}}
\newcommand{\solution}{\noindent \textbf{Solution: }}
\newcommand{\cosec}{\,\text{cosec}\,}
\providecommand{\dec}[2]{\ensuremath{\overset{#1}{\underset{#2}{\gtrless}}}}
\newcommand{\myvec}[1]{\ensuremath{\begin{pmatrix}#1\end{pmatrix}}}
\newcommand{\mydet}[1]{\ensuremath{\begin{vmatrix}#1\end{vmatrix}}}
\renewcommand{\vec}[1]{\boldsymbol{\mathbf{#1}}}
\def\putbox#1#2#3{\makebox[0in][l]{\makebox[#1][l]{}\raisebox{\baselineskip}[0in][0in]{\raisebox{#2}[0in][0in]{#3}}}}
     \def\rightbox#1{\makebox[0in][r]{#1}}
     \def\centbox#1{\makebox[0in]{#1}}
     \def\topbox#1{\raisebox{-\baselineskip}[0in][0in]{#1}}
     \def\midbox#1{\raisebox{-0.5\baselineskip}[0in][0in]{#1}}

\vspace{3cm}
\title{Indoor Wireless Beacon Tracking Using ESP32}
\author{
    \IEEEauthorblockN{Gautam Singh, G.V.V. Sharma} \\
    \IEEEauthorblockA{Indian Institute of Technology Hyderabad, India} \\
    Email: cs21btech11018@iith.ac.in, gadepall@ee.iith.ac.in
}
\maketitle
% \tableofcontents
\bigskip

\begin{abstract}
    This document is a report which demonstrates the use of machine learning in
    beacon tracking using an unmanned ground vehicle (UGV) and a WiFi-enabled
    microcontroller such as the ESP32.
\end{abstract}

\section{Introduction and Related Work}
\label{sec:intro}

Positioning, localization and navigation (PLAN) technology has become an
essential capability for consumer household devices such as robot vacuums and
autonomous vehicles alike. This fast growing market has seen the entry of big
tech giants such as Amazon, Apple and Google. Use cases of PLAN include safety,
medical applications and assistance for the elderly and the specially abled.
Reliable PLAN technology can reduce road accidents, congestion, energy and time
consumption. A comprehensive survey of PLAN technology presented in
\cite{el-sheimyIndoorNavigationState2021} categorizes these technologies based
on the primary sensors used in navigation and illustrates the trade-offs between
accuracy, cost, and complexity. Some of these technologies are briefly described
below.

The authors of \cite{narayananFuzzyGuidedAutonomous2022} present a fuzzy
controller system consisting of three ultrasonic sensors and one camera to
detect obstacles in the robot's vicinity. The navigation logic is implemented on
a BLE tag module using the angle of arrival (AOA) method and is suitable for
unmanned nursing in hospitals, especially during pandemic outbreaks. The authors
of \cite{familiIDROPRobustLocalization2023} propose iDROP, a 3-D localization
scheme for drones in indoor GPS-denied environments that is robust against noise
and multipath fading and provides location estimation with high accuracy. The
authors of \cite{htROSPoweredAutonomous2024} present a UGV powered by the robot
operating system (ROS) that uses light detection and ranging (LiDAR) for
accurate navigation even in dynamic conditions, suitable for various indoor
robotic use cases such as in warehouses or construction sites. The authors of
\cite{yukhimetsLocalNavigationSystem2024} present a cost-effective and scalable
navigation system for ESP32 microcontrollers using multiple BLE beacons. A
neural network is employed to model the position of the robot based on the
signal strength received from various BLE beacons and the Levenberg-Marquardt
method is used to accurately estimate the position of the robot. The authors of
\cite{stefasUAVLandingUnknown2019} present a strategy for landing a UAV using a
radio beacon that exploits a special structure occurring when approaching the
target beacon from above to reduce the flight time required for landing near the
beacon.

Methods based on artificial intelligence (AI) have gained popularity in recent
literature. The authors of \cite{liuSimpleOnlineUnmanned2021} propose an easy to
implement method for multi-object tracking (MOT) using an encoder-decoder
mechanism. Their proposed method achieves comparable performance with
state-of-the-art frameworks on the challenging MOT dataset. The authors of
\cite{masmitjaReinforcementLearningPath2022} leverage deep reinforcement
learning (RL) to train an agent for tracking dynamically moving objects using
unmanned surface vehicles (USV) in marine environments. The trained RL agent
performs comparably to the analytically derived trajectory in the steady state.
The authors of \cite{kashyapAutonomousNavigationROS22025} explore multiple RL
algorithms using LiDAR inputs on TurtleBot3, showing that the twin delayed deep
deterministic policy gradient (TD3) is the most efficient and robust across
varied environments.

Many of the above methods are either too complex or too expensive to be
implemented on cheap hardware such as an ESP32 microcontroller. Furthermore, a
lot of supporting infrastructure needs to be set up to enable autonomous
navigation. Our work aims to provide a lightweight and cost-effective solution
for indoor beacon tracking using easily available wireless-capable
microcontrollers such as the ESP32. The main contributions of this paper are as
follows.

\begin{enumerate}
    \item A simple yet robust algorithm for indoor beacon tracking using only
    RSSI measurements from a single target beacon.
    \item A practical implementation of the algorithm on an ESP32
    microcontroller mounted on a UGV chassis using open-source frameworks such
    as PlatformIO.
\end{enumerate}

\section{Preliminaries}
\label{sec:prelims}

To estimate (radial) distance to beacon, we use its signal strength. For WiFi,
this is the \textbf{Received Signal Strength Indicator} (RSSI). The RSSI (in
dBm) at radial distance of \(r\) metres is given by
\begin{align}
    R\brak{r} = R\brak{1} - 10\log_{10}\brak{r}
    \label{eq:rssi}
\end{align}
where \(R\brak{1}\) is the RSSI at a distance of 1 metre from the beacon. The
beacon tracking problem can be formulated as the following optimization problem.
\begin{equation}
    \max_{r} R\brak{r} \text{ s.t. } r > 0.
    \label{eq:rssopt}
\end{equation}

The derivative and second derivative of \(R\brak{r}\) is given by
\begin{align}
    R^\prime\brak{r} &= -\frac{10}{\ln{10}}\frac{1}{r}, \label{eq:rssid} \\
    R^{\prime\prime}\brak{r} &= \frac{10}{\ln{10}}\frac{1}{r^2} > 0. \label{eq:rssidd}
\end{align}
Notice that for \(r > 0\), \(R^\prime\brak{r} < 0\), thus \(R\brak{r}\) is a
decreasing function of \(r\). This implies that the maximum RSSI is at \(r =
0\), as expected. Since \(R\brak{r}\) is a convex function of \(r\), we can use
gradient ascent to recursively find the point where the RSSI is maximum, which
would correspond to the location of the beacon. Using \eqref{eq:rssid}, the
gradient ascent update equation is given by
\begin{equation}
    r_{n+1} = r_n + \alpha R^\prime\brak{r_n} = r_n - \frac{10\alpha}{r_n\ln{10}}
    \label{eq:gradient-ascent-upd}
\end{equation}
where \(r_i\) is the radial distance at the \(i\)-th step and \(\alpha\) is the
step size. Since \(r_n > 0\), we can see that \(r_{n+1} < r_n\) for all \(n\).
In other words, the radial distance to the beacon is decreasing with each step.
This means that the UGV will converge towards the beacon. However, due to the
explosion of the gradient in \eqref{eq:rssid}, the update steps become larger as
\(r_n\) decreases, which could lead to overshooting the beacon. To prevent this,
the UGV uses a recursive algorithm to update its position using this principle
until it is close enough to the beacon based on the RSSI measurements it takes
at various points in the vicinity of its current position. The algorithm is
described in \autoref{alg:beacon}.

\begin{algorithm}[H]
    \caption{Beacon Tracking Algorithm}
    \label{alg:beacon}
    \begin{algorithmic}[1]
        \Ensure{RSSI threshold \(T\), number of steps \(N\)}
        \While{\textsc{GetRSSI()} \(< T\)}
            \State Take \(N\) steps in a straight line and measure the RSSI at 
            each step.
            \State Suppose the maximum RSSI is measured at step \(i\).
            \State Move to the position at step \(i\)
            \If{\(i = N\)}
                \State Move one step forward.
            \ElsIf{\(i = 0\)}
                \State Move one step backward.
            \Else
                \State Turn left.
            \EndIf
        \EndWhile
    \end{algorithmic}
\end{algorithm}

\section{Implementation}

\subsection{Assets}
\begin{enumerate}
    \item UGV chassis with DC motors
    \item ESP32 microcontroller with Type-B USB cable
    \item L293D Motor Driver IC
    \item Breadboard and Jumper Wires
    \item Android phone
    \item (Optional) USB 2.0/3.0 Hub
\end{enumerate}

\subsection{Procedure}
\begin{enumerate}
    \item Make the connections as per the wiring diagram in
    \autoref{fig:beacon}.
    \item Connect the ESP32 board to your Android Phone.
    \item Generate the firmware by entering the following commands.
        \begin{lstlisting}
$ cd codes
$ pio run
        \end{lstlisting}
    \item Go to ArduinoDroid and select
        \begin{lstlisting}
Actions - Upload - Upload Precompiled
        \end{lstlisting}
    and choose the firmware file at
        \begin{lstlisting}
codes/.pio/build/firmware.hex
        \end{lstlisting}
    \item Now put the phone at a reasonable distance from the UGV with no
    obstacles in the way and then turn on the hotspot. The UGV should travel
    towards the phone and stop near it.
\end{enumerate}

\begin{figure}[t]
    \centering
    \includegraphics[width=\columnwidth]{figs/beacon.png}
    \caption{Wiring Diagram for Beacon Tracking.}
    \label{fig:beacon}
\end{figure}

\section{Results}
The UGV eventually converges close to the beacon (here, the hotspot). However,
if there are a lot of nearby obstacles, the UGV may not converge close to the
location of the beacon. It may either get physically blocked by the beacon or
the signal interference may be too high.

\nocite{*}
\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}
